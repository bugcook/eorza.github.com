---
layout: post
title: 懒惰的程序员
slug: lazy-programer
date: 2012-04-16 08:32:00 +0800
excerpt: 可能除了哲学家以外，笔者认为程序员是最懒的一群人。他们的职业看起来又似乎有一定的劳动强度。
categories:
- other
tags:
- computer
- program
more_categories:
- slug: other
  name: 转载
more_tags:
- slug: computer
  name: 电脑
- slug: program
  name: 编程
---

可能除了哲学家以外，笔者认为程序员是最懒的一群人。他们的职业看起来又似乎有一定的劳动强度。

想想看，生物学家要亲自做所有的实验…给数百只小白鼠注射药物不可能自动完成。医生必须给病人进行身体检查；教授每年都要教授同样的课程；建筑师从各个角度制定方案，并手工地将方案一笔一划绘制出来。

让我们再来看看更为辛苦的一些职业，情况更糟。营销人员要不断重复地进行同样的产品宣传；理发师日复一日地做着同样的事情；收营员每天都以相同的方式对货物进行结算…工厂工人…

你面前呈现出了一幅图片，世界上有很多这样的人，他们每一小时，每一天，每一年，有些甚至一辈子都在重复做着几乎相同的事情。

## 来看看程序员

每当我们想连续两次做同样的事情时—我们会尝试想一个方法来自动完成此过程。每当你写的代码是完成同样的一件事时，你会开始寻找一个库；每当你启动一个类似的项目时，你会去寻找一个模板。

程序员的生活就是致力于消除重复的工作。

<figure>
	<img src="{{ site.path.uploads }}2012/04/16/lazy-programer/coding.jpg" alt="coding" />
</figure>

将琐碎地任务从我们的工作流程中剔除，这能让每个人生活得更轻松。这里有一个经典的笑话，说一个程序员情愿用一周的时间来写一个拷贝脚本，也不愿意将相同的文件复制粘贴两次，尽管复制粘贴可能只需要两分钟。

该死的，我们要遵循DRY（Don’t Repeat Yourself不要重复自己）的原则。这个原则的基本内容是宁愿创建一个令人费解的抽象类，也不要将不相同但非常相似的代码写两次。

这当然会导致很多问题。

一般的软件项目充满了在顶层抽象类上构建的抽象类，你慢慢地会不清楚这些顶层抽象类将如何工作。甚至你完全不知道其代码在做什么。”Dizzying but invisible depth“，涉及到这个问题时，你真的应该读读这篇短文。


另一方面，懒惰本身已经证明了历史上许多科学和工程发展所带来的背后推动力。用有轮子的拖车运东西比人工搬运要轻松；用船在水中前行比游泳来得容易；甚至如果你他妈的想炸掉一座城市，你投掷一颗原子弹也比投掷几千个小炸弹来的容易。

所以这也许并不是说程序员是懒惰的。也许真正懒惰地是工程师们。只是恰巧在这样一个历史时刻，程序员作为工程师中最鲜明的一类，总是将世界向更好更光明的未来推动。而其它大多数领域已经在某种程度上稳定下来，或者需要更长的时间去适应新的工具。

这里有一个重要的问题要问：程序员天生就懒吗？聪明懒惰的人容易被编程工作吸引吗，或者这是一种社会效应？懒惰源于最好的编程实践？还是最好的编程实践源于懒惰呢？

## 一个比较

最近，我有机会将一个建筑专业学生的一天与一个计算机科学专业的学生（就像我自己）的一天进行比较。

大多数的建筑系学生的生活充满了这样或那样劳动密集的任务，这些任务是她工作的一部分。在任何时候，她都有可能要对一些模型进行拼凑粘合，在AutoCAD中从50个不同的角度对同一个物体进行绘图，或者在其它3D建模软件中重复相同的事情…然后将这些图片导入到Photoshop中成为真正好看的图。

这种事会接连不断的发生。我估计她花费在课程作业上的时间比她实际上课的时间多一倍还不止（事实上她说花了5倍还多）。更糟糕的是，更好的完成这些任务并不能真正加快完成任务的进程，这只是意味着你多知道了几个键盘快捷键，意味着下次画图时你可能会少犯几个错误。

熟练和精通完全无法优化关键的部分。

相比之下，当我不上课时，我通常都在做自己的项目。因为我可以，因为我有充足的时间。当有作业布置下来时，一般情况下，我都可以在几个小时内完成…即使是最关键最重要的项目，老师也很少给我们超过一周的时间来集中完成作业，最多两周。

精通编码并不意味着你打字更快（与建筑专业中等同的能力不同）。它意味着想出的解决方案更容易实现，利用工具来达到事倍功半的效果，诸如此类。最终，通过互联网进行测试评判，而实现过程是最无关紧要的部分，因为每个人都会。如果你有一天的时间，你可以实现某些东西。如果你有更多的时间，你可以使这些东西实现得更漂亮，模块化更高，可重用性更强，等等。

基本上你能够快速地实现眼前的任务，你工作中大部分时间都在致力于使你的任务完成得更加漂亮。但这对于你手头的任务来说其实并不重要，你这样做是因为你可以。

甚至于当程序员对自己的优化工作都产生厌倦时，他们会立马转而去创建工具来完成优化工作。

事情就这样周而复始地重复着。

接下来的家伙会使用他创建的新工具，使实现过程变得更快，接着优化它直到他最终厌倦，然后创建了一个新的更好的工具。

## 所以…是辛苦的工作？

但回到我最初的观点，辛苦工作对程序员的生产效率存在多大的影响？对于那些每天辛苦工作13小时以上，以取得竞争优势的创业者来说，这又意味着什么？这是值得考虑的一种优势吗？

辛苦的工作可能对程序员工作效率产生负面的影响。它掩盖了背后所做的优化工作“哦，我可以手动把它完成，这将只需要10分钟时间”（其实这需要20分钟）。下一次，一个相似的任务到来时，你可能需要再次手动把它完成，长此以往…

最重要的是，辛勤地工作会使你变得很笨。许多研究表明，持续疲劳的状态会使你做出错误的决策，甚至过多的决策也会让你会出错误的决定（称为决策疲劳）。事情上，这可能是我们喜欢创建抽象类并使用它们的原因—让其它人做大多数的决策，这样我就可以只专注于关键的部分。

但是，我仍然没弄懂，到底是懒惰的人更喜欢编程，还是编程使他们变得懒惰…
